#!/usr/bin/env python3
"""
ChatTTS Command Line Client
For TTS project benchmarking
"""

import sys
import argparse
import os
from pathlib import Path
import warnings

# Suppress warnings
warnings.filterwarnings('ignore')
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

def main():
    parser = argparse.ArgumentParser(
        description="ChatTTS Command Line Client - Convert text to speech",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic usage
  %(prog)s -t "Hello World" -o output.wav
  
  # Read text from file
  %(prog)s -f input.txt -o output.wav
  
  # Specify speaker and parameters
  %(prog)s -t "Test speech" -o test.wav --speaker 123 --temperature 0.3
  
  # Use refine to improve quality
  %(prog)s -t "High quality speech" -o high_quality.wav --refine
        """
    )
    
    # Input arguments
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument('-t', '--text', 
                           help='Text to convert')
    input_group.add_argument('-f', '--file', 
                           help='Input file containing text')
    
    # Output arguments
    parser.add_argument('-o', '--output', required=True,
                       help='Output audio file path (WAV format)')
    
    # ChatTTS parameters
    parser.add_argument('--speaker', type=int, default=None,
                       help='Speaker seed (for voice control)')
    parser.add_argument('--temperature', type=float, default=0.3,
                       help='Temperature parameter, controls randomness (default: 0.3)')
    parser.add_argument('--top-p', type=float, default=0.7,
                       help='Top-P sampling parameter (default: 0.7)')
    parser.add_argument('--top-k', type=int, default=20,
                       help='Top-K sampling parameter (default: 20)')
    parser.add_argument('--refine', action='store_true',
                       help='Use text refinement to improve quality')
    
    # Device parameters
    parser.add_argument('--device', default='auto',
                       choices=['auto', 'cpu', 'cuda', 'mps'],
                       help='Device to use (default: auto)')
    parser.add_argument('--compile', action='store_true',
                       help='Use torch.compile for acceleration (requires PyTorch 2.0+)')
    
    # Other parameters
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Show verbose information')
    parser.add_argument('--sample-rate', type=int, default=24000,
                       help='Sample rate (default: 24000)')
    
    args = parser.parse_args()
    
    # Get input text
    if args.text:
        text = args.text
    else:
        input_path = Path(args.file)
        if not input_path.exists():
            print(f"Error: Input file does not exist: {args.file}", file=sys.stderr)
            sys.exit(1)
        try:
            with open(input_path, 'r', encoding='utf-8') as f:
                text = f.read().strip()
        except Exception as e:
            print(f"Error: Failed to read input file: {e}", file=sys.stderr)
            sys.exit(1)
    
    if not text:
        print("Error: Input text is empty", file=sys.stderr)
        sys.exit(1)
    
    if args.verbose:
        print(f"Input text: {text}")
        print(f"Output file: {args.output}")
    
    # Import ChatTTS
    try:
        import ChatTTS
        import torch
        import torchaudio
    except ImportError as e:
        print(f"Error: Missing required library: {e}", file=sys.stderr)
        print("\nPlease install ChatTTS and its dependencies:", file=sys.stderr)
        print("  pip install ChatTTS torch torchaudio", file=sys.stderr)
        sys.exit(1)
    
    # Determine device
    if args.device == 'auto':
        if torch.cuda.is_available():
            device = 'cuda'
        elif hasattr(torch.backends, 'mps') and torch.backends.mps.is_available():
            device = 'mps'
        else:
            device = 'cpu'
    else:
        device = args.device
    
    if args.verbose:
        print(f"Using device: {device}")
    
    # Initialize ChatTTS
    try:
        if args.verbose:
            print("Initializing ChatTTS...")
        
        chat = ChatTTS.Chat()
        
        # Load model
        load_success = chat.load(
            compile=args.compile,
            device=device
        )
        
        if not load_success:
            print("Error: ChatTTS model loading failed", file=sys.stderr)
            sys.exit(1)
        
        if args.verbose:
            print("Model loaded successfully")
        
        # Prepare parameters
        params_infer_code = ChatTTS.Chat.InferCodeParams(
            temperature=args.temperature,
            top_P=args.top_p,
            top_K=args.top_k,
        )
        
        params_refine_text = ChatTTS.Chat.RefineTextParams()
        
        # Set speaker
        if args.speaker is not None:
            torch.manual_seed(args.speaker)
            if args.verbose:
                print(f"Using speaker seed: {args.speaker}")
        
        # Generate speech
        if args.verbose:
            print("Generating speech...")
        
        # Process text
        texts = [text]
        
        # Use refine if requested
        if args.refine:
            if args.verbose:
                print("Applying text refinement...")
            texts = chat.infer(
                texts,
                skip_refine_text=False,
                refine_text_only=True,
                params_refine_text=params_refine_text
            )
            if args.verbose:
                print(f"Refined text: {texts[0]}")
        
        # Generate audio
        wavs = chat.infer(
            texts,
            skip_refine_text=True,
            params_infer_code=params_infer_code
        )
        
        if not wavs or len(wavs) == 0:
            print("Error: Audio generation failed", file=sys.stderr)
            sys.exit(1)
        
        # Save audio
        if args.verbose:
            print(f"Saving audio to: {args.output}")
        
        output_path = Path(args.output)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Convert numpy array to torch tensor and save
        audio_data = torch.from_numpy(wavs[0]).unsqueeze(0)
        torchaudio.save(
            str(output_path),
            audio_data,
            args.sample_rate,
            encoding='PCM_S',
            bits_per_sample=16
        )
        
        if args.verbose:
            print("âœ“ Done")
        else:
            # In non-verbose mode, only output file path for script processing
            print(args.output)
    
    except KeyboardInterrupt:
        print("\nOperation interrupted", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
