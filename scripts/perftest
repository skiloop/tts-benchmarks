#!/usr/bin/env python3
"""
æ€§èƒ½æµ‹è¯•å·¥å…· - ä½¿ç”¨ /usr/bin/time æµ‹è¯•å’Œæ¯”è¾ƒå¤šç§å‘½ä»¤çš„æ€§èƒ½
"""

import sys
import subprocess
import argparse
import json
import re
import statistics
from pathlib import Path
from typing import List, Dict, Tuple
from dataclasses import dataclass, asdict
import time as time_module

@dataclass
class TimeResult:
    """æ—¶é—´æµ‹è¯•ç»“æœ"""
    real: float  # å®é™…è¿è¡Œæ—¶é—´ï¼ˆç§’ï¼‰
    user: float  # ç”¨æˆ·æ€CPUæ—¶é—´ï¼ˆç§’ï¼‰
    sys: float   # å†…æ ¸æ€CPUæ—¶é—´ï¼ˆç§’ï¼‰
    
    def total_cpu(self) -> float:
        """æ€»CPUæ—¶é—´"""
        return self.user + self.sys

@dataclass
class TestResult:
    """æµ‹è¯•ç»“æœ"""
    name: str
    command: str
    runs: List[TimeResult]
    success: bool
    error_msg: str = ""
    
    def avg_real(self) -> float:
        return statistics.mean([r.real for r in self.runs]) if self.runs else 0
    
    def avg_user(self) -> float:
        return statistics.mean([r.user for r in self.runs]) if self.runs else 0
    
    def avg_sys(self) -> float:
        return statistics.mean([r.sys for r in self.runs]) if self.runs else 0
    
    def avg_total_cpu(self) -> float:
        return statistics.mean([r.total_cpu() for r in self.runs]) if self.runs else 0
    
    def std_real(self) -> float:
        return statistics.stdev([r.real for r in self.runs]) if len(self.runs) > 1 else 0
    
    def min_real(self) -> float:
        return min([r.real for r in self.runs]) if self.runs else 0
    
    def max_real(self) -> float:
        return max([r.real for r in self.runs]) if self.runs else 0


class Colors:
    """ç»ˆç«¯é¢œè‰²"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'
    
    @staticmethod
    def disable():
        """ç¦ç”¨é¢œè‰²"""
        Colors.HEADER = ''
        Colors.BLUE = ''
        Colors.CYAN = ''
        Colors.GREEN = ''
        Colors.YELLOW = ''
        Colors.RED = ''
        Colors.BOLD = ''
        Colors.UNDERLINE = ''
        Colors.END = ''


def parse_time_output(output: str) -> TimeResult:
    """è§£æ /usr/bin/time çš„è¾“å‡º"""
    # macOS å’Œ Linux çš„ time è¾“å‡ºæ ¼å¼å¯èƒ½ä¸åŒ
    # macOS: "0.00 real         0.00 user         0.00 sys"
    # Linux: "0.00user 0.00system 0:00.00elapsed"
    
    real = user = sys = 0.0
    
    # å°è¯•åŒ¹é… macOS æ ¼å¼
    mac_pattern = r'(\d+\.\d+)\s+real\s+(\d+\.\d+)\s+user\s+(\d+\.\d+)\s+sys'
    match = re.search(mac_pattern, output)
    if match:
        real = float(match.group(1))
        user = float(match.group(2))
        sys = float(match.group(3))
        return TimeResult(real, user, sys)
    
    # å°è¯•åŒ¹é… Linux æ ¼å¼
    linux_pattern = r'(\d+\.\d+)user\s+(\d+\.\d+)system\s+(\d+):(\d+\.\d+)elapsed'
    match = re.search(linux_pattern, output)
    if match:
        user = float(match.group(1))
        sys = float(match.group(2))
        minutes = int(match.group(3))
        seconds = float(match.group(4))
        real = minutes * 60 + seconds
        return TimeResult(real, user, sys)
    
    # å°è¯•æ›´é€šç”¨çš„æ¨¡å¼
    real_match = re.search(r'(\d+\.\d+)\s*(?:real|elapsed)', output, re.IGNORECASE)
    user_match = re.search(r'(\d+\.\d+)\s*user', output, re.IGNORECASE)
    sys_match = re.search(r'(\d+\.\d+)\s*sys(?:tem)?', output, re.IGNORECASE)
    
    if real_match:
        real = float(real_match.group(1))
    if user_match:
        user = float(user_match.group(1))
    if sys_match:
        sys = float(sys_match.group(1))
    
    return TimeResult(real, user, sys)


def run_command_with_time(command: str, shell: bool = True, debug: bool = False) -> Tuple[TimeResult, bool, str]:
    """ä½¿ç”¨ /usr/bin/time è¿è¡Œå‘½ä»¤"""
    time_cmd = f"/usr/bin/time {command}" if shell else ["/usr/bin/time"] + command.split()
    
    try:
        # /usr/bin/time çš„è¾“å‡ºé€šå¸¸åœ¨ stderr
        result = subprocess.run(
            time_cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        if debug:
            print(f"  DEBUG - time stderr output:\n{result.stderr}")
        
        # è§£æ time è¾“å‡º
        time_result = parse_time_output(result.stderr)
        
        if debug:
            print(f"  DEBUG - parsed result: real={time_result.real}, user={time_result.user}, sys={time_result.sys}")
        
        return time_result, result.returncode == 0, ""
        
    except Exception as e:
        return TimeResult(0, 0, 0), False, str(e)


def run_test(name: str, command: str, iterations: int, verbose: bool = False, debug: bool = False) -> TestResult:
    """è¿è¡Œæ€§èƒ½æµ‹è¯•"""
    print(f"{Colors.CYAN}æµ‹è¯• [{name}]: {Colors.END}{command}")
    
    runs = []
    success = True
    error_msg = ""
    
    for i in range(iterations):
        if verbose:
            print(f"  è¿è¡Œ {i+1}/{iterations}...", end=' ', flush=True)
        
        time_result, cmd_success, error = run_command_with_time(command, debug=debug)
        
        if not cmd_success:
            success = False
            error_msg = error or "å‘½ä»¤æ‰§è¡Œå¤±è´¥"
            if verbose:
                print(f"{Colors.RED}âœ—{Colors.END}")
            break
        
        runs.append(time_result)
        if verbose:
            print(f"{Colors.GREEN}âœ“{Colors.END} ({time_result.real:.3f}s)")
    
    if not verbose and success:
        print(f"  {Colors.GREEN}å®Œæˆ {iterations} æ¬¡è¿è¡Œ{Colors.END}")
    elif not success:
        print(f"  {Colors.RED}å¤±è´¥: {error_msg}{Colors.END}")
    
    return TestResult(name, command, runs, success, error_msg)


def print_summary(results: List[TestResult]):
    """æ‰“å°æµ‹è¯•æ‘˜è¦"""
    print(f"\n{Colors.BOLD}{Colors.HEADER}{'='*80}{Colors.END}")
    print(f"{Colors.BOLD}{Colors.HEADER}æ€§èƒ½æµ‹è¯•æ‘˜è¦{Colors.END}")
    print(f"{Colors.BOLD}{Colors.HEADER}{'='*80}{Colors.END}\n")
    
    # è¿‡æ»¤æˆåŠŸçš„ç»“æœ
    successful_results = [r for r in results if r.success and r.runs]
    
    if not successful_results:
        print(f"{Colors.RED}æ‰€æœ‰æµ‹è¯•éƒ½å¤±è´¥äº†æˆ–æ²¡æœ‰æœ‰æ•ˆçš„æµ‹è¯•ç»“æœ{Colors.END}")
        return
    
    # è¿‡æ»¤æ‰æ—¶é—´ä¸º0çš„ç»“æœï¼ˆtimeè§£æå¤±è´¥ï¼‰
    valid_results = [r for r in successful_results if r.avg_real() > 0]
    
    if not valid_results:
        print(f"{Colors.RED}æ— æ³•è§£ææ—¶é—´æ•°æ®ï¼Œè¯·æ£€æŸ¥ /usr/bin/time çš„è¾“å‡ºæ ¼å¼{Colors.END}")
        print(f"{Colors.YELLOW}æç¤º: æŸäº›ç³»ç»Ÿçš„ time å‘½ä»¤æ ¼å¼å¯èƒ½ä¸åŒ{Colors.END}")
        return
    
    # æ‰¾å‡ºæœ€å¿«çš„
    fastest = min(valid_results, key=lambda r: r.avg_real())
    
    # æ‰“å°ç»“æœè¡¨æ ¼
    print(f"{Colors.BOLD}{'åç§°':<20} {'å®é™…æ—¶é—´':<15} {'ç”¨æˆ·æ—¶é—´':<15} {'ç³»ç»Ÿæ—¶é—´':<15} {'ç›¸å¯¹é€Ÿåº¦':<10}{Colors.END}")
    print("-" * 80)
    
    for result in sorted(valid_results, key=lambda r: r.avg_real()):
        relative_speed = result.avg_real() / fastest.avg_real()
        color = Colors.GREEN if result == fastest else Colors.END
        
        name_str = result.name[:18] + ".." if len(result.name) > 20 else result.name
        real_str = f"{result.avg_real():.3f}s Â±{result.std_real():.3f}"
        user_str = f"{result.avg_user():.3f}s"
        sys_str = f"{result.avg_sys():.3f}s"
        rel_str = f"{relative_speed:.2f}x"
        
        print(f"{color}{name_str:<20} {real_str:<15} {user_str:<15} {sys_str:<15} {rel_str:<10}{Colors.END}")
    
    # æ‰“å°è¯¦ç»†ç»Ÿè®¡
    print(f"\n{Colors.BOLD}è¯¦ç»†ç»Ÿè®¡:{Colors.END}")
    for result in sorted(valid_results, key=lambda r: r.avg_real()):
        print(f"\n{Colors.CYAN}{Colors.BOLD}[{result.name}]{Colors.END}")
        print(f"  å‘½ä»¤: {result.command}")
        print(f"  å¹³å‡å®é™…æ—¶é—´: {result.avg_real():.3f}s (æœ€å°: {result.min_real():.3f}s, æœ€å¤§: {result.max_real():.3f}s)")
        print(f"  å¹³å‡ç”¨æˆ·æ—¶é—´: {result.avg_user():.3f}s")
        print(f"  å¹³å‡ç³»ç»Ÿæ—¶é—´: {result.avg_sys():.3f}s")
        print(f"  å¹³å‡CPUæ—¶é—´:  {result.avg_total_cpu():.3f}s")
        if len(result.runs) > 1:
            print(f"  æ ‡å‡†å·®: {result.std_real():.3f}s")
        
        relative_to_fastest = result.avg_real() / fastest.avg_real()
        if result == fastest:
            print(f"  {Colors.GREEN}ğŸ† æœ€å¿«!{Colors.END}")
        else:
            slower_percent = (relative_to_fastest - 1) * 100
            print(f"  æ¯”æœ€å¿«æ…¢ {slower_percent:.1f}% ({relative_to_fastest:.2f}x)")
    
    # æ‰“å°å¤±è´¥çš„æµ‹è¯•
    failed_results = [r for r in results if not r.success]
    if failed_results:
        print(f"\n{Colors.RED}{Colors.BOLD}å¤±è´¥çš„æµ‹è¯•:{Colors.END}")
        for result in failed_results:
            print(f"  {Colors.RED}âœ—{Colors.END} [{result.name}]: {result.error_msg}")


def load_config(config_file: str) -> Dict:
    """åŠ è½½é…ç½®æ–‡ä»¶"""
    config_path = Path(config_file)
    if not config_path.exists():
        print(f"{Colors.RED}é”™è¯¯: é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_file}{Colors.END}")
        sys.exit(1)
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        print(f"{Colors.RED}é”™è¯¯: é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯: {e}{Colors.END}")
        sys.exit(1)


def save_results_json(results: List[TestResult], output_file: str):
    """ä¿å­˜ç»“æœä¸º JSON"""
    data = {
        "timestamp": time_module.strftime("%Y-%m-%d %H:%M:%S"),
        "results": [
            {
                "name": r.name,
                "command": r.command,
                "success": r.success,
                "error_msg": r.error_msg,
                "avg_real": r.avg_real(),
                "avg_user": r.avg_user(),
                "avg_sys": r.avg_sys(),
                "std_real": r.std_real(),
                "min_real": r.min_real(),
                "max_real": r.max_real(),
                "runs": [asdict(run) for run in r.runs]
            }
            for r in results
        ]
    }
    
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    
    print(f"\n{Colors.GREEN}ç»“æœå·²ä¿å­˜åˆ°: {output_file}{Colors.END}")


def create_sample_config(filename: str):
    """åˆ›å»ºç¤ºä¾‹é…ç½®æ–‡ä»¶"""
    sample_config = {
        "description": "æ€§èƒ½æµ‹è¯•é…ç½®ç¤ºä¾‹",
        "iterations": 3,
        "tests": [
            {
                "name": "grep-standard",
                "command": "grep -r 'pattern' /path/to/dir"
            },
            {
                "name": "grep-perl",
                "command": "grep -P -r 'pattern' /path/to/dir"
            },
            {
                "name": "ripgrep",
                "command": "rg 'pattern' /path/to/dir"
            }
        ]
    }
    
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(sample_config, f, indent=2, ensure_ascii=False)
    
    print(f"{Colors.GREEN}ç¤ºä¾‹é…ç½®æ–‡ä»¶å·²åˆ›å»º: {filename}{Colors.END}")


def main():
    parser = argparse.ArgumentParser(
        description="æ€§èƒ½æµ‹è¯•å·¥å…· - ä½¿ç”¨ /usr/bin/time æµ‹è¯•å’Œæ¯”è¾ƒå¤šç§å‘½ä»¤çš„æ€§èƒ½",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  # ä»å‘½ä»¤è¡ŒæŒ‡å®šå‘½ä»¤
  %(prog)s -c "sleep 1" -c "sleep 0.5" -n 3
  
  # ä½¿ç”¨é…ç½®æ–‡ä»¶
  %(prog)s -f config.json
  
  # åˆ›å»ºç¤ºä¾‹é…ç½®æ–‡ä»¶
  %(prog)s --sample-config perftest.json
  
  # æŒ‡å®šå‘½ä»¤åç§°
  %(prog)s -t "slow,sleep 1" -t "fast,sleep 0.5" -n 5 -v
  
  # ä¿å­˜ç»“æœ
  %(prog)s -f config.json -o results.json
        """
    )
    
    parser.add_argument('-c', '--command', action='append', dest='commands',
                        help='è¦æµ‹è¯•çš„å‘½ä»¤ï¼ˆå¯å¤šæ¬¡æŒ‡å®šï¼‰')
    parser.add_argument('-t', '--test', action='append', dest='tests',
                        help='å‘½åæµ‹è¯•ï¼Œæ ¼å¼: "åç§°,å‘½ä»¤"ï¼ˆå¯å¤šæ¬¡æŒ‡å®šï¼‰')
    parser.add_argument('-f', '--config', dest='config_file',
                        help='ä» JSON é…ç½®æ–‡ä»¶åŠ è½½æµ‹è¯•')
    parser.add_argument('-n', '--iterations', type=int, default=3,
                        help='æ¯ä¸ªå‘½ä»¤è¿è¡Œçš„æ¬¡æ•°ï¼ˆé»˜è®¤: 3ï¼‰')
    parser.add_argument('-o', '--output', dest='output_file',
                        help='ä¿å­˜ç»“æœåˆ° JSON æ–‡ä»¶')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='è¯¦ç»†è¾“å‡ºæ¯æ¬¡è¿è¡Œçš„ç»“æœ')
    parser.add_argument('--debug', action='store_true',
                        help='è°ƒè¯•æ¨¡å¼ï¼Œæ˜¾ç¤º time å‘½ä»¤çš„åŸå§‹è¾“å‡º')
    parser.add_argument('--no-color', action='store_true',
                        help='ç¦ç”¨å½©è‰²è¾“å‡º')
    parser.add_argument('--sample-config', dest='sample_config',
                        help='åˆ›å»ºç¤ºä¾‹é…ç½®æ–‡ä»¶')
    
    args = parser.parse_args()
    
    # ç¦ç”¨é¢œè‰²
    if args.no_color:
        Colors.disable()
    
    # åˆ›å»ºç¤ºä¾‹é…ç½®
    if args.sample_config:
        create_sample_config(args.sample_config)
        return
    
    # æ”¶é›†æµ‹è¯•ä»»åŠ¡
    tests = []
    
    # ä»å‘½ä»¤è¡Œå‚æ•°
    if args.commands:
        for i, cmd in enumerate(args.commands):
            tests.append({
                'name': f'command-{i+1}',
                'command': cmd
            })
    
    # ä»å‘½åæµ‹è¯•
    if args.tests:
        for test_str in args.tests:
            parts = test_str.split(',', 1)
            if len(parts) != 2:
                print(f"{Colors.RED}é”™è¯¯: æµ‹è¯•æ ¼å¼é”™è¯¯: {test_str}{Colors.END}")
                print(f"åº”è¯¥æ˜¯: 'åç§°,å‘½ä»¤'")
                sys.exit(1)
            tests.append({
                'name': parts[0].strip(),
                'command': parts[1].strip()
            })
    
    # ä»é…ç½®æ–‡ä»¶
    if args.config_file:
        config = load_config(args.config_file)
        if 'tests' in config:
            tests.extend(config['tests'])
        if 'iterations' in config and not args.iterations != 3:  # å¦‚æœæ²¡æœ‰å‘½ä»¤è¡ŒæŒ‡å®š
            args.iterations = config['iterations']
    
    # éªŒè¯
    if not tests:
        parser.print_help()
        print(f"\n{Colors.RED}é”™è¯¯: è¯·è‡³å°‘æŒ‡å®šä¸€ä¸ªæµ‹è¯•å‘½ä»¤{Colors.END}")
        sys.exit(1)
    
    # æ‰“å°æµ‹è¯•ä¿¡æ¯
    print(f"{Colors.BOLD}{Colors.HEADER}æ€§èƒ½æµ‹è¯•å·¥å…·{Colors.END}")
    print(f"æ€»å…± {len(tests)} ä¸ªæµ‹è¯•ï¼Œæ¯ä¸ªè¿è¡Œ {args.iterations} æ¬¡\n")
    
    # è¿è¡Œæµ‹è¯•
    results = []
    for i, test in enumerate(tests, 1):
        print(f"\n{Colors.BOLD}[{i}/{len(tests)}]{Colors.END}")
        result = run_test(test['name'], test['command'], args.iterations, args.verbose, args.debug)
        results.append(result)
    
    # æ‰“å°æ‘˜è¦
    print_summary(results)
    
    # ä¿å­˜ç»“æœ
    if args.output_file:
        save_results_json(results, args.output_file)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}æµ‹è¯•è¢«ä¸­æ–­{Colors.END}")
        sys.exit(130)

